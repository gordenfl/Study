# Inverted Index (倒排索引)

What is Inverted Index?
首先倒排索引是一个为了搜索引擎的需求来创建的一种索引方式.

正排索引: 一般的方式是从 文档->文字的索引关系,就是拿到一个文档,可以读取文档中的信息找到文字
倒排索引: 一般的方式是从 文字->文档的索引关系, 就是通过一个文字找到跟这个文字相关的文档.

具体实现:

1. 文本处理:
    * 分词(分词的技术稍后再说), 将文本提取成一个一个的token
    * 除去一般没有意义的词,比如:了,的, 和,等助词.
    * 提取词干, 还原词形, 比如:done-> do, running-> run 等等

2. 构建词典(Dictionary)
    维护一个词典,存储所有出现过的词,便于快速查找和索引
3. 统计词项位置和频率
    * 对每个文档中出现的词, 记录他们的文档ID, 词频(TF, term Frequency) 和词语出现的位置, 例如 电脑 出现在 Document1 的第三个词的位置
4. 构建倒排列表:(Posting List)
    * 对每个词语, 维护一个倒排列表, 列表中存储的都是这个词出现过的文档ID, 词频, 位置等信息
    * 例如: 单词1 -> [(document1, 5次, [位置1, 位置2... 位置5] ), (document2, 10次, [位置1, 位置2... 位置10] ), .....]
    * 序列化存储: 倒排列表写入磁盘,通常以压缩格式存储,方便快速读取, 为什么压缩格式存储到磁盘增加效率,是因为更多的时间是消耗在磁盘读取的上的,相比起CPU内存的解析速度,磁盘会慢很多.

倒排索引的优化:

1. 压缩技术
    * 存储的文档ID的差值,而不是具体的文档的ID,(TODO: 这里要弄清楚为什么差值就减少存储?)
    * 对数字进行可变长的编码处理,就是减少0bit的浪费.(太牛逼!!!!)
2. 跳跃表:(Skip-List)
    * 就是上一个文章所讲的数据结构在这里用上了
3. 分块处理:
    将倒排列表分块(TODO: 后面弄清楚), 便于部分加载和并行处理
4. 词频和倒排列表排序优化
    根据词频或者文档重要性对倒排列表排序, 便于优先返回更相关的文档
5. 增量与合并(Merge)
    搜索系统经常会动态添加文档, 倒排的更新采用增量索引效率和一致性(TODO: 后续弄清)
6. 使用布隆过滤器:
    前面学过的Bloom Filter, 快速判断词是否存在索引中, 减少磁盘IO
7. 缓存热门词的倒排列表
    快速判断词是否存在于索引中, 快速宿响应查询请求
8. 倒排索引分片和分布式存储:
    对于海量数据,倒排索引分布在多个节点上,只是并行查询和扩展.

